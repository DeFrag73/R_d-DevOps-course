# R_d-DevOps-course

# TASK № 2

# Vagrant Multi-VM Setup for Web Servers

![Vagrant](https://img.shields.io/badge/Vagrant-2.2-blue)
![VirtualBox](https://img.shields.io/badge/VirtualBox-6.x-orange)
![Ubuntu](https://img.shields.io/badge/Ubuntu-24.04-green)
![Apache](https://img.shields.io/badge/Apache-2.4-lightgrey)

## Проект: Автоматизоване створення кількох віртуальних серверів

Цей проект демонструє, як за допомогою **Vagrant** і **VirtualBox** можна автоматизувати створення кількох віртуальних машин для вебсерверів з різними мережевими налаштуваннями та спільними папками. Ми використовуємо **Ubuntu 24.04** як базову операційну систему та встановлюємо вебсервер **Apache** для кожної машини.

### Основні характеристики:

- **6 віртуальних машин**, що налаштовані для різних типів мереж (публічна і приватна).
- **Apache** автоматично встановлюється на кожній віртуальній машині.
- Спільні папки для кожної машини, що дозволяють синхронізувати файли між хостом та віртуальними машинами.
- Статичні та динамічні IP-адреси, в залежності від типу сервера.
- Використання циклів для уникнення дублювання коду при створенні кількох схожих віртуальних машин.

## Структура проекту

```
├── Vagrantfile               # Головний файл конфігурації для Vagrant
├── shared_vm                 # Спільна папка для webserver-01
├── shared_vm_4               # Спільна папка для webserver-04
├── shared_vm_5               # Спільна папка для webserver-05
├── shared_vm_6               # Спільна папка для webserver-06
└── README.md                 # Цей файл
```

## Деталі налаштувань

- **webserver-01**: Загальнодоступний вебсервер із динамічним IP. Цей сервер піднімається за допомогою публічної мережі та отримує IP автоматично.
  
- **private_server_02**: Приватний сервер із статичним IP `1.1.1.212`. Цей сервер налаштований для приватної мережі.

- **webserver-03**: Загальнодоступний сервер із статичним IP `1.1.1.213` і мостовим підключенням через адаптер `Realtek Gaming 2.5GbE Family Controller`.

- **webserver-04, webserver-05, webserver-06**: Три додаткові вебсервери з унікальними статичними IP-адресами (від `1.1.1.14` до `1.1.1.16`), створені автоматично за допомогою циклу, щоб уникнути дублювання коду.

### Використані технології:

- **Vagrant** — інструмент для управління середовищем віртуалізації.
- **VirtualBox** — платформа для запуску віртуальних машин.
- **Ubuntu 24.04** — операційна система для кожної віртуальної машини.
- **Apache** — вебсервер, встановлений автоматично через Vagrant provision.

## Інструкція для запуску

### Передумови

Для запуску проекту вам знадобляться:

- [Vagrant](https://www.vagrantup.com/downloads)
- [VirtualBox](https://www.virtualbox.org/wiki/Downloads)

### Кроки для запуску:

1. **Клонування репозиторію**:

   ```bash
   git clone https://github.com/yourusername/vagrant-multi-vm-setup.git
   cd vagrant-multi-vm-setup
   ```

2. **Запуск віртуальних машин**:

   У каталозі з файлом `Vagrantfile` виконайте команду:

   ```bash
   vagrant up
   ```

   Ця команда автоматично завантажить необхідні образи, створить віртуальні машини та виконає всі налаштування, в тому числі встановить Apache.

3. **Доступ до вебсерверів**:

   Після завершення процесу підняття віртуальних машин ви можете отримати доступ до вебсерверів за IP-адресами, зазначеними у `Vagrantfile`. Наприклад:

   - Для `webserver-01`: Отримайте динамічний IP через `vagrant ssh webserver-01` і використовуйте `ifconfig` або `ip a` для перегляду IP.
   - Для інших серверів з статичними IP просто введіть їх IP в браузері, наприклад: `http://192.168.33.14`.

4. **Зупинка віртуальних машин**:

   Після завершення роботи ви можете зупинити всі машини за допомогою команди:

   ```bash
   vagrant halt
   ```

5. **Видалення віртуальних машин**:

   Якщо більше не потрібно використовувати віртуальні машини, їх можна видалити:

   ```bash
   vagrant destroy -f
   ```

## Висновок

Цей проект демонструє, як за допомогою Vagrant можна швидко та автоматизовано створювати складні середовища для розгортання вебсерверів. Завдяки використанню циклів для створення схожих машин, код стає чистішим і легше підтримується. Якщо ви плануєте розгортати тестові або навчальні середовища, цей проект може стати чудовою основою для подальшої автоматизації.

## Ліцензія

Цей проект ліцензований під MIT License — детальніше дивіться у файлі [LICENSE](./LICENSE).

# TASK № 3


# Проект: Встановлення та налаштування Nginx, Systemd сервісу, UFW та Fail2Ban

## Опис проекту
У цьому проекті ми виконуємо декілька основних завдань:
1. Встановлюємо вебсервер Nginx через офіційний репозиторій, оновлюємо через PPA-репозиторій, а потім повертаємось до офіційної версії через ppa-purge.
2. Створюємо власний Systemd сервіс та налаштовуємо Systemd таймер для автоматичного виконання простого скрипта.
3. Налаштовуємо UFW (брандмауер), щоб заблокувати доступ до SSH з одного IP та дозволити з іншого.
4. Додатково: Налаштовуємо Fail2Ban для захисту від підбору паролів через SSH.

## Встановлення та налаштування Nginx

### Крок 1: Додавання офіційного PPA-репозиторію для Nginx
Для початку додаємо PPA-репозиторій для Nginx та оновлюємо версію пакета.

```bash
sudo add-apt-repository ppa:nginx/stable
sudo apt update
sudo apt upgrade nginx
```
*Після додавання репозиторію, перевіряємо версію Nginx до та після оновлення.*

![add repo.png](task_2_Linux%2Fscreenshots%2Fadd%20repo.png)

### Крок 2: Перевірка версії Nginx до та після додавання репозиторію
Перед додаванням PPA:
![Версія до оновлення](file-lKzJPmJaLGfpd7Fg1Sr2BxuT)

Після оновлення через PPA:
![Версія після оновлення](file-s3Lj8xI1FpqpOeiIKyiNgjWp)

### Крок 3: Повернення до офіційної версії за допомогою ppa-purge
Після встановлення пакета з PPA, ми можемо повернутись до офіційної версії Nginx за допомогою команди:

```bash
sudo ppa-purge ppa:nginx/stable
```
![Видалення PPA-репозиторію](file-T7ss5tgcGXCvmpjRm9vkyBls)

---

## Створення та налаштування Systemd сервісу

### Крок 1: Створення скрипта для запису часу у файл
Ми створюємо простий скрипт, який записує поточний час у файл `/var/log/time.log`.

```bash
#!/bin/bash
echo "Current time: $(date)" >> /var/log/time.log
```
![Скрипт](file-8xXadgUCC2h2EdgtLEXtcRzR)

### Крок 2: Створення сервісу Systemd
Створюємо файл сервісу `log_time.service`, який буде запускати наш скрипт.

```bash
sudo nano /etc/systemd/system/log_time.service
```
Зміст файлу:
```ini
[Unit]
Description=Log time to file

[Service]
ExecStart=/usr/local/bin/log_time.sh
```
![Systemd-сервіс](file-zcpKDSizGK9TTdRQEt9tcrcZ)

### Крок 3: Створення Systemd таймера для автоматичного виконання скрипта
Щоб не використовувати нескінченний цикл зі `sleep`, ми налаштовуємо Systemd таймер для запуску скрипта щохвилини.

```bash
sudo nano /etc/systemd/system/log_time.timer
```
Зміст файлу:
```ini
[Unit]
Description=Run time logger script every minute

[Timer]
OnBootSec=1min
OnUnitActiveSec=1min

[Install]
WantedBy=timers.target
```
![Створення таймера](file-0iV6t8ETdaRLoeACaQyQ0wHt)

### Крок 4: Перевірка роботи Systemd таймера
Після активації таймера, перевіряємо, чи виконується скрипт і чи записується час у файл.

![Перевірка роботи](file-3WIYK8CHeNeMSiCOQoYk4l7r)

---

## Налаштування UFW (брандмауера)

### Крок 1: Заборона доступу до SSH з певного IP
Щоб заблокувати доступ до SSH з певної IP-адреси (наприклад, `192.168.0.2`), але дозволити з іншої IP-адреси (`192.168.0.3`), використовуємо наступні команди:

```bash
sudo ufw deny from 192.168.0.2 to any port 22
sudo ufw allow from 192.168.0.3 to any port 22
```
![Налаштування UFW](file-3u0QYVXBcxtJv3SUimv8ifWY)

---

## Висновок
У цьому проекті ми виконали наступні завдання:
1. Встановили Nginx з офіційного репозиторію, оновили його через PPA і повернулися до офіційної версії.
2. Створили власний systemd-сервіс та налаштували таймер для запуску скрипта щохвилини.
3. Налаштували UFW для блокування доступу до порту SSH з певного IP і дозволили доступ з іншого IP.

---

## Налаштування Fail2Ban

Fail2Ban — це програма, яка сканує журнали на предмет невдалих спроб авторизації та блокує IP-адреси з підозрілою активністю.

### Крок 1: Встановлення Fail2Ban
Встановлюємо Fail2Ban за допомогою стандартного менеджера пакетів:

```bash
sudo apt install fail2ban
```

### Крок 2: Налаштування захисту SSH
Створюємо або редагуємо файл конфігурації `/etc/fail2ban/jail.local`:

```bash
sudo nano /etc/fail2ban/jail.local
```

Додаємо наступну конфігурацію для захисту SSH:

```ini
[sshd]
enabled = true
port = 22
maxretry = 3
bantime = 600
```

- **maxretry** — кількість невдалих спроб перед блокуванням.
- **bantime** — час блокування IP-адреси в секундах (600 секунд = 10 хвилин).

### Крок 3: Перезапуск Fail2Ban
Після внесення змін перезапускаємо Fail2Ban:

```bash
sudo systemctl restart fail2ban
```

### Крок 4: Перевірка статусу Fail2Ban
Для перевірки статусу Fail2Ban і підключених до нього сервісів можна скористатися командою:

```bash
sudo fail2ban-client status sshd
```

---

## Додаткове завдання: Створення та монтування нового розділу

### Крок 1: Створення нового розділу
Для початку, створюємо новий розділ на вільному дисковому просторі за допомогою `fdisk`.

```bash
sudo fdisk /dev/sdb
```

Виконуємо наступні дії:
- Натискаємо **n** для створення нового розділу.
- Приймаємо стандартні налаштування для початкового та кінцевого сектора.
- Натискаємо **w** для збереження змін.

### Крок 2: Форматування розділу
Після створення розділу, форматуємо його у файлову систему `ext4`.

```bash
sudo mkfs.ext4 /dev/sdb1
```

### Крок 3: Отримання UUID розділу
Щоб уникнути проблем із перепризначенням пристроїв після перезавантаження, використовуємо UUID для монтування. Отримуємо UUID за допомогою команди:

```bash
sudo blkid /dev/sdb1
```

### Крок 4: Створення точки монтування
Створюємо директорію, куди буде монтуватись новий розділ:

```bash
sudo mkdir /mnt/new_partition
```

### Крок 5: Додавання запису до fstab
Відкриваємо файл `/etc/fstab` для редагування:

```bash
sudo nano /etc/fstab
```

Додаємо наступний рядок:

```
UUID=<UUID> /mnt/new_partition ext4 defaults 0 2
```

### Крок 6: Монтування розділу
Після редагування `fstab`, монтуємо всі файлові системи:

```bash
sudo mount -a
```

Перевіряємо, чи успішно змонтовано новий розділ:

```bash
lsblk
```

Після виконання цих дій новий розділ буде змонтовано автоматично при кожному завантаженні системи.

# TASK 4


# Автоматична установка пакетів для різних дистрибутивів Linux

Цей Bash-скрипт дозволяє автоматично встановлювати та налаштовувати пакети (Apache, MariaDB, UFW, Docker) на різних дистрибутивах Linux (Ubuntu, Fedora, CentOS, Debian). Він також підтримує встановлення додаткових пакетів, зазначених користувачем під час запуску скрипта.

## Опис функціональності

### Основні можливості:
1. **Визначення дистрибутива**: Скрипт автоматично визначає операційну систему, на якій виконується, використовуючи файл `/etc/os-release`.
2. **Оновлення репозиторіїв**: Перед встановленням пакунків скрипт оновлює репозиторії залежно від дистрибутива.
3. **Встановлення базових пакетів**: Основні пакети, які встановлюються за замовчуванням:
   - Apache (веб-сервер)
   - MariaDB (сервер баз даних)
   - UFW (брандмауер для Ubuntu/Debian)
   - Docker (система для запуску контейнерів)
4. **Оновлення встановлених пакетів**: Якщо пакет уже встановлений, він буде оновлений до останньої версії.
5. **Встановлення додаткових пакетів**: Можна передати додаткові пакети як аргументи до скрипта, і вони також будуть встановлені.
6. **Налаштування UFW**: Для дистрибутивів Ubuntu/Debian налаштовується UFW для дозволу трафіку через порти, що використовуються Apache, MariaDB і Docker.
7. **Довідка (help)**: Скрипт підтримує параметр `--help` або `help`, який виводить інструкції з використання.

## Як використовувати скрипт

### 1. Клонування або копіювання скрипта
Скачайте або скопіюйте скрипт на ваш сервер.

### 2. Надання прав на виконання
Перед тим, як запускати скрипт, потрібно надати йому права на виконання. Виконайте команду:

```bash
chmod +x ./install_packages.sh
```

### 3. Запуск скрипта

#### 3.1 Встановлення основних пакетів
Щоб встановити базові пакети (Apache, MariaDB, UFW, Docker), просто запустіть скрипт:

```bash
./install_packages.sh
```

#### 3.2 Встановлення додаткових пакетів
Щоб встановити основні пакети та додаткові пакунки (наприклад, git, vim, curl), запустіть скрипт із зазначенням потрібних пакетів через пробіл:

```bash
./install_packages.sh git vim curl
```

#### 3.3 Виведення довідки
Щоб переглянути довідку щодо використання скрипта, виконайте команду:

```bash
./install_packages.sh --help
```

Або:

```bash
./install_packages.sh help
```

## Підтримувані дистрибутиви
Скрипт підтримує такі дистрибутиви Linux:
- Ubuntu
- Debian
- Fedora
- CentOS
- RHEL

## Налаштування firewall (UFW)
Для дистрибутивів Ubuntu та Debian скрипт автоматично налаштовує UFW для дозволу таких портів:
- **80, 443** (Apache)
- **3306** (MariaDB)
- **2375** (Docker)

Для інших дистрибутивів налаштування firewall не виконується, оскільки вони не використовують UFW за замовчуванням.

## Приклад використання

1. Встановити лише основні пакети (apache, mariadb, ufw, docker):

    ```bash
    ./install_packages.sh
    ```

2. Встановити основні пакети та додаткові пакети (наприклад, `git`, `vim`, `curl`):

    ```bash
    ./install_packages.sh git vim curl
    ```

3. Вивести довідку про використання:

    ```bash
    ./install_packages.sh --help
    ```

